import kerbal.iterator.iterator;import kerbal.iterator.iterator_traits;import kerbal.operators.addable;import kerbal.type_traits;import kerbal.utility.addressof;import kerbal.utility.in_place;import kerbal.utility.member_compress_helper;import <iostream>;using std::cout;using std::endl;using std::boolalpha;struct Foo{};void test_iterator(){	using namespace kerbal::iterator;		cout << is_random_access_iterator<int*>::value << endl;	int arr[10];	int * p = arr;	cout << distance(p, next(p)) << endl;}void test_operators(){	kerbal::operators::addable<Foo> add;}void test_type_traits(){	using namespace kerbal::type_traits;		cout << kerbal::type_traits::is_const<int>::value << endl;}void test_utility(){	using namespace kerbal::utility;		{		int x;		cout << kerbal::utility::addressof(x) << endl;	}		{		member_compress_helper<int> mch;		int x = mch.member();		member_compress_helper<int&> mch2(kerbal::utility::in_place_t(), x);	}}int main(){	std::cout << std::boolalpha;			test_iterator();	test_operators();	test_type_traits();	}